import{c as v}from"./server-fns-runtime-4T1EILgx.js";import{d as f}from"./db.server-BYnrqg0d.js";import"solid-js/web";import"solid-js/web/storage";import"./fetchEvent-1KlzQMFw.js";import"h3";import"node:async_hooks";import"pg";const C=v(async function(e){if(!e||e.toUpperCase()==="EUR")return console.log("[getExchangeRate] Tasso per EUR richiesto, restituisco 1."),1;console.log(`[getExchangeRate] Recupero tasso per ${e}...`);try{const a=await f.query("SELECT rate FROM exchange_rates WHERE currency_code = $1 ORDER BY observation_date DESC LIMIT 1",[e.toUpperCase()]);if(a.rows.length>0){const r=a.rows[0].rate;return console.log(`[getExchangeRate] Tasso trovato per ${e}: ${r}`),r}else return console.warn(`[getExchangeRate] Tasso non trovato nel DB per ${e}. Restituisco null.`),null}catch(a){throw console.error(`[getExchangeRate] Errore recupero tasso per ${e}:`,a),new Error(`Errore DB recupero tasso per ${e}`)}},"src_routes_API_exchangeRates_exchangeRates_ts--getExchangeRate_1","C:/Users/Matteo/Desktop/Pulsix/src/routes/API/exchangeRates/exchangeRates.ts?tsr-directive-use-server="),T=v(async function(e,a){const r=e.toUpperCase(),o=a.toUpperCase();if(console.log(`[getConversionRate] Richiesto tasso da ${r} a ${o}`),r===o)return console.log(`[getConversionRate] Stessa valuta (${r}), tasso restituito: 1`),1;try{const t=await _(r),n=await _(o);if(console.log(`[getConversionRate] Tasso DB (EUR -> ${r}): ${t}`),console.log(`[getConversionRate] Tasso DB (EUR -> ${o}): ${n}`),t===null||n===null)return console.warn(`[getConversionRate] Impossibile calcolare ${r} -> ${o}. Tasso EUR->${r} (${t}) o EUR->${o} (${n}) mancante.`),null;if(t===0)return console.error(`[getConversionRate] Impossibile calcolare ${r} -> ${o}. Tasso EUR->${r} è zero.`),null;const i=n/t;return console.log(`[getConversionRate] Tasso calcolato ${r} -> ${o}: ${n} / ${t} = ${i}`),i}catch(t){return console.error(`[getConversionRate] Errore durante calcolo tasso ${r} -> ${o}:`,t),null}},"src_routes_API_exchangeRates_exchangeRates_ts--getConversionRate_1","C:/Users/Matteo/Desktop/Pulsix/src/routes/API/exchangeRates/exchangeRates.ts?tsr-directive-use-server="),B=v(async function(e,a,r){const o="[Server Function:calculateConvertedTotalWithDeleteCheck]";if(isNaN(r)||r<=0)throw console.error(`${o} User ID non valido: ${r}`),new Error("User ID non valido.");if(e!==null&&(typeof e!="number"||isNaN(e)||e<=0))throw console.error(`${o} Container ID non valido: ${e}`),new Error("Container ID non valido.");if(typeof a!="string"||a.trim().length<3)throw console.error(`${o} Codice valuta target non valido: ${a}`),new Error("Codice valuta target non valido.");const t=a.toUpperCase();console.log(`${o} Inizio per container ${e??"ROOT"} -> ${t}, user ${r}`);let n=0;const i=[];try{const c=`
          WITH RECURSIVE WalletHierarchy AS (
              -- Anchor Member: Seleziona i figli diretti del container (o root)
              -- che NON sono stati eliminati.
              SELECT id, balance, currency, type, container_id
              FROM public.wallets
              WHERE user_id = $1
                AND ${e===null?"container_id IS NULL":"container_id = $2"}
                AND date_of_delete IS NULL -- <<< Esclude figli diretti eliminati

              UNION ALL

              -- Recursive Member: Seleziona i figli (w) degli elementi trovati (wh)
              -- assicurandosi che i figli (w) NON siano stati eliminati.
              SELECT w.id, w.balance, w.currency, w.type, w.container_id
              FROM public.wallets w
              JOIN WalletHierarchy wh ON w.container_id = wh.id -- Join con passo precedente
              WHERE w.user_id = $1 -- Verifica opzionale ma sicura
                AND w.date_of_delete IS NULL -- <<< Esclude elementi ricorsivi eliminati
                -- Non serve controllare wh.date_of_delete qui, è già filtrato prima
          )
          -- Seleziona i dettagli necessari SOLO dai WALLET validi trovati nella gerarchia
          SELECT id, balance, currency
          FROM WalletHierarchy
          WHERE type = 'wallet'           -- Considera solo i wallet
            AND balance IS NOT NULL     -- Ignora wallet con saldo nullo
            AND currency IS NOT NULL;     -- Ignora wallet con valuta nulla
      `,w=e===null?[r]:[r,e];console.log(`${o} Query: ${c.replace(/\s+/g," ").trim()}, Params: ${JSON.stringify(w)}`);const g=(await f.query(c,w)).rows??[];if(console.log(`${o} Trovati ${g.length} wallet validi (non eliminati, con saldo e valuta) nella gerarchia.`),g.length===0)return{total_balance:0,currency_code:t};const $=[...new Set(g.map(s=>s.currency.toUpperCase()).filter(s=>s!==t))],h=new Map;if($.length>0){console.log(`${o} Recupero tassi per: ${$.join(", ")} -> ${t}`);const s=$.map(l=>m(l,t).catch(u=>(console.error(`${o} Errore recupero tasso per ${l}:`,u),null))),R=await Promise.all(s);$.forEach((l,u)=>{const E=R[u];if(h.set(l,E),E===null){const d=`Tasso di cambio non trovato o errore per ${l} -> ${t}. I saldi in ${l} verranno ignorati.`;i.push(d),console.warn(`${o} ${d}`)}})}h.set(t,1);for(const s of g){const R=s.balance;if(!s.currency)continue;const l=s.currency.toUpperCase(),u=h.get(l);typeof u=="number"&&!isNaN(u)?n+=Math.round(R*u*100)/100:l!==t&&console.warn(`${o} Salto wallet ${s.id} (${R} ${l}) per tasso mancante/non valido.`)}return n=Math.round(n*100)/100,console.log(`${o} Calcolo completato. Totale in ${t}: ${n}`),{total_balance:n,currency_code:t,warnings:i.length>0?i:void 0}}catch(c){throw console.error(`${o} Errore critico per container ${e??"ROOT"} in ${t}, user ${r}:`,c),c instanceof Error&&"code"in c&&console.error(`DB Error Code: ${c.code}`),new Error(`Errore nel calcolo del totale convertito per container ${e??"ROOT"}.`)}},"src_routes_API_exchangeRates_exchangeRates_ts--calculateConvertedTotal_1","C:/Users/Matteo/Desktop/Pulsix/src/routes/API/exchangeRates/exchangeRates.ts?tsr-directive-use-server="),I=v(async function(e,a,r){if(e==null||isNaN(e))return console.warn(`[convertBalance] Ricevuto balance non valido o mancante: ${e}. Restituisco null.`),null;if(!a||!r)return console.warn(`[convertBalance] Ricevuto fromCurrencyCode (${a}) o toCurrencyCode (${r}) mancante. Restituisco null.`),null;const o=a.toUpperCase(),t=r.toUpperCase();if(console.log(`[convertBalance] Richiesta conversione: ${e} ${o} -> ${t}`),o===t)return console.log(`[convertBalance] Valute identiche (${o}). Restituisco balance originale: ${e}`),e;try{const n=await m(o,t);if(n===null)return console.warn(`[convertBalance] Tasso da ${o} a ${t} non disponibile. Impossibile convertire.`),null;const i=e*n;return console.log(`[convertBalance] Convertito: ${e} ${o} * ${n} = ${i.toFixed(4)} ${t}`),i}catch(n){return console.error(`[convertBalance] Errore durante la conversione di ${e} ${o} a ${t}:`,n),null}},"src_routes_API_exchangeRates_exchangeRates_ts--convertBalance_1","C:/Users/Matteo/Desktop/Pulsix/src/routes/API/exchangeRates/exchangeRates.ts?tsr-directive-use-server="),_=C,m=T;export{B as calculateConvertedTotal_1,I as convertBalance_1,T as getConversionRate_1,C as getExchangeRate_1};

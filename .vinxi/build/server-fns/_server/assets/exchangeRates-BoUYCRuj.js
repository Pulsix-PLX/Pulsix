import{c as v}from"./server-fns-runtime-DEO2-sKc.js";import{d as _}from"./db.server-CDeyn5Z_.js";import"solid-js/web";import"solid-js/web/storage";import"./fetchEvent-BW7O4Ysp.js";import"h3";import"vite-plugin-node-polyfills/shims/global";import"node:async_hooks";import"vite-plugin-node-polyfills/shims/process";import"pg";const C=v(async function(e){if(!e||e.toUpperCase()==="EUR")return 1;try{const n=await _.query("SELECT rate FROM exchange_rates WHERE currency_code = $1 ORDER BY observation_date DESC LIMIT 1",[e.toUpperCase()]);return n.rows.length>0?n.rows[0].rate:(console.warn(`[getExchangeRate] Tasso non trovato nel DB per ${e}. Restituisco null.`),null)}catch(n){throw console.error(`[getExchangeRate] Errore recupero tasso per ${e}:`,n),new Error(`Errore DB recupero tasso per ${e}`)}},"src_routes_API_exchangeRates_exchangeRates_ts--getExchangeRate_1","C:/Users/Matteo/Desktop/Pulsix/src/routes/API/exchangeRates/exchangeRates.ts?tsr-directive-use-server="),N=v(async function(e,n){const r=e.toUpperCase(),o=n.toUpperCase();if(r===o)return 1;try{const t=await $(r),a=await $(o);return t===null||a===null?(console.warn(`[getConversionRate] Impossibile calcolare ${r} -> ${o}. Tasso EUR->${r} (${t}) o EUR->${o} (${a}) mancante.`),null):t===0?(console.error(`[getConversionRate] Impossibile calcolare ${r} -> ${o}. Tasso EUR->${r} è zero.`),null):a/t}catch(t){return console.error(`[getConversionRate] Errore durante calcolo tasso ${r} -> ${o}:`,t),null}},"src_routes_API_exchangeRates_exchangeRates_ts--getConversionRate_1","C:/Users/Matteo/Desktop/Pulsix/src/routes/API/exchangeRates/exchangeRates.ts?tsr-directive-use-server="),M=v(async function(e,n,r){const o="[Server Function:calculateConvertedTotalWithDeleteCheck]";if(isNaN(r)||r<=0)throw console.error(`${o} User ID non valido: ${r}`),new Error("User ID non valido.");if(e!==null&&(typeof e!="number"||isNaN(e)||e<=0))throw console.error(`${o} Container ID non valido: ${e}`),new Error("Container ID non valido.");if(typeof n!="string"||n.trim().length<3)throw console.error(`${o} Codice valuta target non valido: ${n}`),new Error("Codice valuta target non valido.");const t=n.toUpperCase();let a=0;const u=[];try{const l=`
          WITH RECURSIVE WalletHierarchy AS (
              -- Anchor Member: Seleziona i figli diretti del container (o root)
              -- che NON sono stati eliminati.
              SELECT id, balance, currency, type, container_id
              FROM public.wallets
              WHERE user_id = $1
                AND ${e===null?"container_id IS NULL":"container_id = $2"}
                AND date_of_delete IS NULL -- <<< Esclude figli diretti eliminati

              UNION ALL

              -- Recursive Member: Seleziona i figli (w) degli elementi trovati (wh)
              -- assicurandosi che i figli (w) NON siano stati eliminati.
              SELECT w.id, w.balance, w.currency, w.type, w.container_id
              FROM public.wallets w
              JOIN WalletHierarchy wh ON w.container_id = wh.id -- Join con passo precedente
              WHERE w.user_id = $1 -- Verifica opzionale ma sicura
                AND w.date_of_delete IS NULL -- <<< Esclude elementi ricorsivi eliminati
                -- Non serve controllare wh.date_of_delete qui, è già filtrato prima
          )
          -- Seleziona i dettagli necessari SOLO dai WALLET validi trovati nella gerarchia
          SELECT id, balance, currency
          FROM WalletHierarchy
          WHERE type = 'wallet'           -- Considera solo i wallet
            AND balance IS NOT NULL     -- Ignora wallet con saldo nullo
            AND currency IS NOT NULL;     -- Ignora wallet con valuta nulla
      `,m=e===null?[r]:[r,e],g=(await _.query(l,m)).rows??[];if(g.length===0)return{total_balance:0,currency_code:t};const w=[...new Set(g.map(s=>s.currency.toUpperCase()).filter(s=>s!==t))],h=new Map;if(w.length>0){const s=w.map(i=>f(i,t).catch(c=>(console.error(`${o} Errore recupero tasso per ${i}:`,c),null))),p=await Promise.all(s);w.forEach((i,c)=>{const d=p[c];if(h.set(i,d),d===null){const E=`Tasso di cambio non trovato o errore per ${i} -> ${t}. I saldi in ${i} verranno ignorati.`;u.push(E),console.warn(`${o} ${E}`)}})}h.set(t,1);for(const s of g){const p=s.balance;if(!s.currency)continue;const i=s.currency.toUpperCase(),c=h.get(i);typeof c=="number"&&!isNaN(c)?a+=Math.round(p*c*100)/100:i!==t&&console.warn(`${o} Salto wallet ${s.id} (${p} ${i}) per tasso mancante/non valido.`)}return a=Math.round(a*100)/100,{total_balance:a,currency_code:t,warnings:u.length>0?u:void 0}}catch(l){throw console.error(`${o} Errore critico per container ${e??"ROOT"} in ${t}, user ${r}:`,l),l instanceof Error&&"code"in l&&console.error(`DB Error Code: ${l.code}`),new Error(`Errore nel calcolo del totale convertito per container ${e??"ROOT"}.`)}},"src_routes_API_exchangeRates_exchangeRates_ts--calculateConvertedTotal_1","C:/Users/Matteo/Desktop/Pulsix/src/routes/API/exchangeRates/exchangeRates.ts?tsr-directive-use-server="),P=v(async function(e,n,r){if(e==null||isNaN(e))return console.warn(`[convertBalance] Ricevuto balance non valido o mancante: ${e}. Restituisco null.`),null;if(!n||!r)return console.warn(`[convertBalance] Ricevuto fromCurrencyCode (${n}) o toCurrencyCode (${r}) mancante. Restituisco null.`),null;const o=n.toUpperCase(),t=r.toUpperCase();if(o===t)return e;try{const a=await f(o,t);return a===null?(console.warn(`[convertBalance] Tasso da ${o} a ${t} non disponibile. Impossibile convertire.`),null):e*a}catch(a){return console.error(`[convertBalance] Errore durante la conversione di ${e} ${o} a ${t}:`,a),null}},"src_routes_API_exchangeRates_exchangeRates_ts--convertBalance_1","C:/Users/Matteo/Desktop/Pulsix/src/routes/API/exchangeRates/exchangeRates.ts?tsr-directive-use-server="),$=C,f=N;export{M as calculateConvertedTotal_1,P as convertBalance_1,N as getConversionRate_1,C as getExchangeRate_1};
